from functools import partial
import itertools
import os
from pkg_resources import resource_filename
import sys

import katuali

KATUALI_VERSION = katuali.__version__
SNAKES = resource_filename('katuali', 'data')

GUPPY_EXEC = os.path.expanduser(config["GUPPY"])
IN_POMOXIS = os.path.expanduser(config["IN_POMOXIS"])
IN_MEDAKA = os.path.expanduser(config["IN_MEDAKA"])
IN_MEDAKA_GPU = os.path.expanduser(config["IN_MEDAKA_GPU"])
CANU_EXEC = os.path.expanduser(config["CANU_EXEC"])
FLYE_EXEC = os.path.expanduser(config["FLYE_EXEC"])
SHASTA_EXEC = os.path.expanduser(config["FLYE_EXEC"])

# Always set the environment
LD_LIBRARY_PATH = config.get("LD_LIBRARY_PATH")
shell.prefix("""
set -euo pipefail;
export LD_LIBRARY_PATH=\"{LD_LIBRARY_PATH}\";
""".format(LD_LIBRARY_PATH=LD_LIBRARY_PATH))

config["THREADS_PER_JOB"] = int(config["THREADS_PER_JOB"])

# NOTE on virtual environments
# Snakemake uses bash strict mode, virtualenv violates bash strict mode.
# https://snakemake.readthedocs.io/en/stable/project_info/faq.html#my-shell-command-fails-with-with-errors-about-an-unbound-variable-what-s-wrong
# so any activation commands must be wrapped as such:
#      set +u; {config[IN_MEDAKA]}; set -u; 


rule version:
    run:
        print('katuali version {}'.format(KATUALI_VERSION))


rule help:
    shell:
        'echo See https://nanoporetech.github.io/katuali/examples.html for help in getting started'


rule environment:
    # Just output the contents of PATH and LD_LIBRARY_PATH to log
    log:
        "katuali.sge.log",
    resources:
        gpu = 0
    shell:
        'echo $PATH; echo $LD_LIBRARY_PATH'


def get_reference(wildcards, config):
    # return the absolute path so that a reference in the working directory
    # e.g. ref.fasta is not confused for a pipeline target, which is
    # distinguished from an explicit target by the lack of a '/' in pipeline targets.  
    return os.path.abspath(config["DATA"][wildcards["runid"]]["REFERENCE"])


def get_contig_opt(wildcards, config):
    if "REGIONS" in config and "REGIONS" != "":
        contig_opt = "-r {}".format(config["REGIONS"])
    elif wildcards.contig == "all_contigs":
        contig_opt = ""
    else:
        contig_opt = "-r {}".format(wildcards.contig)
    logger.run_info("Setting region option to {}".format(contig_opt))
    return contig_opt


def get_opts(wildcards, config, config_key):

    if config_key not in config:
        raise KeyError('{} not in config'.format(config_key))

    suffix = wildcards["suffix"]

    # This allows one to use config entries specified on the command line
    # (which can't be nested)
    # TODO: do we still need this? 
    if not isinstance(config[config_key], dict):
        opts = config[config_key]
        logger.run_info("{} parameters were not nested, using {}".format(config_key, opts))

    elif suffix in config[config_key]:
        opts = config[config_key][suffix]
        logger.run_info("Using {} parameters specified by suffix: \"{}\"".format(config_key, suffix))
    else:
        raise KeyError('{} suffix \"{}\" not in {}'.format(config_key, suffix, set(config[config_key].keys())))

    return opts


def pipeline_targets(wildcards, config=config):
    p = 'all_' + wildcards['pipeline']
    logger.run_info("Creating targets for pipeline: {}".format(p))
    targets = []
    for template in config['PIPELINES'][p]:
        targets.extend(katuali.expand_target_template(template, config))
    return targets


rule pipeline:
    input:
        targets = partial(pipeline_targets, config=config)
    output:
        "all_{pipeline,[^/]*}"


include: os.path.join(SNAKES, "basecalling.snake")
include: os.path.join(SNAKES, "./alignment.snake")
include: os.path.join(SNAKES, "./assembly.snake")
include: os.path.join(SNAKES, "./correction.snake")
include: os.path.join(SNAKES, "./evaluation.snake")
include: os.path.join(SNAKES, "./medaka_train.snake")

